# 3, 4장. 실습을 위한 개발 환경 세팅
* 출처 : https://github.com/slipp/web-application-server
* main 브랜치에서 진행

# 웹 서버 시작 및 테스트
* webserver.WebServer 는 사용자의 요청을 받아 RequestHandler에 작업을 위임하는 클래스이다.
* 사용자 요청에 대한 모든 처리는 RequestHandler 클래스의 run() 메서드가 담당한다.
* WebServer를 실행한 후 브라우저에서 http://localhost:8080으로 접속해 "Hello World" 메시지가 출력되는지 확인한다.

# 각 요구사항별 학습 내용 정리
* 구현 단계에서는 각 요구사항을 구현하는데 집중한다.
* 구현을 완료한 후 구현 과정에서 새롭게 알게된 내용, 궁금한 내용을 기록한다.
* 각 요구사항을 구현하는 것이 중요한 것이 아니라 구현 과정을 통해 학습한 내용을 인식하는 것이 배움에 중요하다.

### 요구사항 1 - http://localhost:8080/index.html로 접속시 응답
- [x] Request Header가 어떻게 생겼는지 파악하기 위해 모두 출력해본다.
- [x] Request Header의 첫번째 줄에서 HTTP method와 요청 url을 구분하여 저장해야 한다.
- [x] `GET /index.html`  요청을 처리할 메서드를 만든다.
- [x] css가 적용되지 않는 문제 해결하기 

[요구사항 1 학습 내용](/requirement/Requirement1.md)

### 요구사항 2 - get 방식으로 회원가입
- [x] 요구사항 1에서 "/" url만 처리하는 메서드가 다른 메서드를 처리하도록 수정
- [x] 쿼리 파라미터에 있는 정보를 파싱하는 방법 알아보기 (? 앞부분은 버리고 → &을 기준으로 파싱 → =을 기준으로 다시 파싱)
- [x] 파싱하여 받은 데이터를 User 객체에 저장하기
- [x] 생성한 User객체 repository에 저장하기
- [x] User 객체에 데이터 저장한 후에 / 화면으로 돌아오도록 url 바꿔주기
  → 계속 오류가 나서 200이 아니라 302 status code로 처리해줌

[요구사항 2 학습 내용](/requirement/Requirement2.md)

### 요구사항 3, 4 - post 방식으로 회원가입 후 redirect 방식으로 이동
- [x] "/user/create" 이 포함된 url은 헤더를 모두 읽으며 Content-Length 정보를 얻고, 이를 통해 body를 읽는 작업을 수행한다.

  (request body를 읽을 때에는 기존에 구현되어 있는 IOUtils 클래스의 `readData()` 메서드를 사용한다.)
- [x] 회원가입 처리를 모두 마친 뒤 홈으로 redirect 처리를 한다. `redirect()`

  `response302Header()`를 통해 response의 상태코드를 302로 설정하고, body에 인자로 받은 url의 html 파일을 넣어 클라이언트에게 전송한다.

### 요구사항 5 - 로그인하기 with cookie
- [x] request body에서 정보를 읽는 과정이 회원가입 처리와 똑같아서 이 부분은 같이 사용하고, 이후 부분만 메서드를 통해 분리한다.

  http method가 POST인 것은 content length 정보와 body 내용을 읽고, 이후 url 분기문을 통해 `signup()`, `login()`을 분리했다.
- 아이디와 비밀번호를 사용해서 repository에 저장된 user를 조회 결과에 따라 `addCookieAndRedirect()` 파라미터에 true/false를 넘겨준다.
- true/false를 response header의 Set-Cookie 필드에 추가한다. 그러면 다음 request 부터는 헤더의 Cookie 필드에 쿠키가 세팅된 것을 확인할 수 있다.

  이 쿠키의 boolean 값으로 로그인 유무를 판단한다.

### 요구사항 6 - 사용자 목록 출력하기
- 쿠키의 login값이 true인 경우에만 사용자 목록을 출력하도록 하고, 회원이 아닌 경우 로그인 페이지로 이동시킨다.
- java의 string builder를 사용하여 html을 모두 저장한다.
- sb를 byte array로 변환한 후 data output stream에 `write()` 한 후, `flush()` 하면 화면에 잘 나온다.

  (list.html 파일을 string builder에 모두 저장해야겠지만,, 너무 양이 많아서 user 목록만 보여주도록 변경했다.

  이러한 단점을 보완하기 위해 서블릿, JSP가 나왔다는 것만 상기하자!)

### 요구사항 7 - css 적용하기
- css의 url을 dos에 적어 response body에 담아줘야 한다!
- 요청 url의 확장자가 css이거나 요청 헤더가 `Accept: text/css,*/*` 인 경우 → 응답 헤더를 `Content-Type: text/css`로 해야한다.

# 5장. HTTP 웹 서버 리팩토링 실습
* refactor 브랜치에서 진행

### 요구사항 1 - 요청 데이터를 처리하는 로직을 별도의 클래스로 분리한다. (HttpRequest)
- `contains()` 와 `split()` 의 동작 방식 : 문자열 처리와 정규 표현식의 차이
  - `contains()` : 정규 표현식이 아니라 단순 문자열 비교. 특정 문자열이 해당 문자열 안에 포함되어 있는지만 확인하는 메서드

    → 특수 문자인 물음표("?")를 이스케이프 처리할 필요가 없다. `url.contains("?")`
  - `split()` : **정규 표현식**을 사용하여 문자열을 분리. 
    
    정규 표현식에서 ?는 특수한 의미를 갖는 문자이므로, 문자 그대로의 물음표를 사용하려면 이스케이프해야 한다. `url.split(\\?)`
- 메타 문자 : 정규 표현식에서 특수한 의미를 갖는 문자. 특정 패턴을 표현하는 데 사용한다.
  
  만약 문자 그대로 사용하고 싶다면 이스케이프 처리를 해줘야 한다.
  
  자주 사용하는 메타 문자 :  `.`(임의 문자), `*`(0번 이상 반복), `+`(1번 이상 반복), `[]`(문자 클래스), `()`(그룹화), `|`(OR 연산), `^`(문자열 시작), `$`(문자열 끝), `{}`(반복 횟수 지정)


- `isEmpty()` 와 `null` 의 차이점
  - `isEmpty()`
    - **값은 있지만 그 값이 비어있는 상태**
    - ex 문자열이지만 글자가 없는 경우 (""), 리스트지만 요소가 없는 경우([])
  - `null`
    - **값이 자체가 없음**
    - 변수에 아무 값도 할당되지 않는 상태
    - 변수 자체가 메모리에 값으로 존재하지 않는 상태

- 테스트 주도 개발 TDD의 장점
  1. 클래스에 버그가 있는지를 빨리 찾아 구현할 수 있다.
  2. 디버깅하기 쉽다.
  3. 테스트 코드가 있기 때문에 마음 놓고 리팩토링 할 수 있다. (리팩토링을 마친 후 테스트를 한번만 실행하면 리팩토링 코드에 대한 검증이 끝난다!)

- 리팩토링 1) 애플리케이션을 개발하면서 private 메서드인데 로직의 복잡도가 높으면 추가적인 테스트가 필요하다. 이 때, 해당 메서드만 별도로 분리해 테스트하기가 힘들다면 아래의 두가지 방법을 고려해야 한다.
  1. 메서드의 private 접근 제어자를 default 접근 제어자로 수정하고 메서드 처리 결과를 반환하도록 수정해 테스트한다. (`processRequestLine()` 메서드의 경우 반환값이 하나가 아니라서 이 방법을 적용할 수 없다.)
  2. 메서드 구현 로직을 새로운 클래스로 분리한다.

- 리팩토링 2) 상수 값이 서로 연관되어 있는 경우 자바의 enum을 쓰기 적합하다!
  - GET, POST 와 같이 문자열로 하드코딩되어 있는 부분
  - 상수 값이 서로 연관된 경우 : 남(M)/여(F), 동(EAST)/서(WEST)/남(SOUTH)/북(NORTH) 등

- 객체 지향 
  - 객체지향 프로그램을 설계할 때에는 요구사항을 분석해 객체로 추상화하는 부분이 가장 중요하다! (연습필수)
  - 항상 객체의 책임이 적절하게 할당되었는지 고려하며 코드를 설계하고 리팩토링을 진행하자.
  - 객체를 최대한 활용하기 : 객체에서 값을 꺼낸 후 로직을 구현하려고 하지 말고 값을 가지고 있는 객체에 메시지를 보내 일을 시키도록 연습한다.

    → 객체를 최대한 활용하다가, 복잡도가 증가하고 책임이 점점 더 많아지는 느낌이 들면 그때 새로운 객체를 추가하자!

⇒ 요구사항 1 구현 후 : 클라이언트 요청을 HttpRequest 라는 객체로 추상화해 구현함으로써 RequestHandler에서 요청 데이터를 조작하는 부분을 제거할 수 있게 됨!

### 요구사항 2 - 응답 데이터를 처리하는 로직을 별도의 클래스로 분리한다. (HttpResponse)
* 응답을 보낼 때 HTML, CSS, 자바스크립트 파일을 직접 읽어 응답을 보내는 메서드는 `forward()`, 다른 URL로 리다이렉트하는 메서드는 `sendRedirect()` 로 나누어 구현한다.

  ⇒ http 메시지에서 header와 body를 구분하는 공백 줄 `"\r\n"`은 `trim().isEmpty()`를 통해 검증해야 한다.
- response header에 key:value를 추가하는 역할과 header의 값을 outputStream에 적는 역할을 구분하여 메서드를 구현한다.
  `addHeader()`, `responseHeader()`
  
  ⇒ redirect 할 때, sendRedirect() 메서드에 로그인 여부와 url을 파라미터로 넘기는 것이 아니라, `response.addHeader()`를 통해 쿠키를 추가한 후 `response.sendRedirect()` 수행

### 요구사항 3 - 다형성을 활용해 클라이언트 요청 URL에 대한 분기 처리를 제거한다.
- 기존 RequestHandler 클래스에서는 기능이 추가될 때마다 url별 분기문이 하나씩 추가되는 방식으로 구현되어 있다.
  
  이는 객체지향 설계 원칙 중 요구사항의 변경이나 추가사항이 발생하더라고 기존 구성요소는 수정이 일어나지 말아야 하며 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 **OCP(개방폐쇄 원칙, Open-Closed Principle)** 원칙에 어긋난다.
- 자바의 다형성을 활용해 새로운 기능이 추가되거나 수정사항이 발생해도 변화의 범위를 최소화하도록 리팩토링 해보자!

  * 다형성이 사용된 부분 : 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만들었다. 상위 클래스 타입의 참조변수`Controller 인터페이스`로 하위 클래스 `~~Controller 클래스`의 객체를 참조했다.

⇒ 요구사항 3 구현 후 : 로그아웃이나 개인정보 수정 등 새로운 기능이 추가돼도 `RequestHandler.run()`의 메서드를 더 이상 수정할 필요가 없다. Controller 구현체 클래스만 추가하면 된다!
```java
  Controller controller = controllers.get(path);
  controller.service(request, response);
```

![class diagram](/requirement/class_diagram1.jpg)
- Controller 인터페이스를 만든다.
- Controller 인터페이스를 구현하는 AbstractController 추상클래스를 만든다. 이 추상클래스의 `service()` 메서드에서는 http method에 따라 다른 처리를 하도록 분기문을 추가했다. (Controller 간의 중복을 최소화하기 위해 중복되는 로직을 추상클래스에 구현한다.) Controller 클래스들은 해당 추상클래스의 구현체이다.
- 각 `method + path`마다 처리해야하는 기능을 Controller 클래스의 `doGet()` 또는 `doPost()` 메서드에 구현

- 추상 클래스에 `abstract` 메서드를 정의해 놓으면 일반 자식 클래스에서는 모두 구현해야 한다.
  
  추상 클래스는 인스턴스화할 수 없고, `abstract`로 선언된 메서드는 자식 클래스에서 반드시 구현되어야 한다.
- abstract 키워드가 붙어있지 않은 메서드는 구현된 메서드로 간주되므로 자식 클래스에서 반드시 구현할 필요가 없다. 
  
  자식 클래스는 선택적으로 해당 메서드를 **재정의(override)**할 수 있지만, 재정의하지 않아도 기본적으로 부모 클래스의 메서드를 사용할 수 있다.

  이 때, 접근제어가 `protected`를 사용하면 외부에서 접근할 수 없고, 자식 클래스에서만 사용할 수 있기 때문에 상속 계층 내에서만 재정의하거나 사용할 수 있다는 점에서 제어 범위를 줄여주는 역할을 한다.

- 헷갈린 점 : 디폴트 메서드는 인터페이스와 관련된 개념이다. 
  - 추상 클래스에 구현된 메서드 : 자식 클래스가 재정의(override)하지 않아도 기본적으로 사용할 수 있으므로 일종의 "디폴트 메서드" 역할을 한다.
  - 인터페이스에서의 디폴트 메서드 : 메서드에 default 키워드를 사용해서 디폴트 메서드를 정의할 수 있다. 디폴트 메서드는 기존에 인터페이스가 구현을 포함하지 못했던 것과 달리, 특정 메서드의 기본 구현을 제공할 수 있도록 한다. → 구현체에서는 디폴트 메서드를 선택적으로 재정의할 수 있다.

- **💥 지금까지 구현한 코드의 문제점**
  - HTTP request, response 처리를 하느라 중요한 로직을 구현할 시간이 줄어든다.
  - 동적인 HTML을 지원하는데 한계가 있다. 동적인 HTML을 구현하기 위해 StringBuilder에 한줄씩 append 함
  - 서버를 재시작하면 사용자가 입력한 데이터가 사라진다.
  - 멀티 스레드 환경인 서블릿 컨테이너에서 하나의 서블릿 인스턴스를 공유하므로 문제가 발생한다.
  
- **🌟 서블릿 컨테이너, 서블릿/JSP를 활용하여 해결하기!**
  - **서블릿** : 이 코드에서 구현한 웹 서버의 Controller, HttpRequest, HttpResponse 를 추상화해 인터페이스로 정의해 놓은 표준
      
    즉, 서블릿은 HTTP의 클라이언트 요청과 응답에 대한 표준을 정해 놓은 것이다.
  
  - **서블릿 컨테이너** : 서블릿 클래스의 인스턴스 생성 + 요청 url과 생성된 서블릿 인스턴스 매핑 + 요청에 해당하는 서블릿 찾은 후 서블릿에 작업 위임 + 서블릿과 관련한 초기화, 소멸 작업 담당 (= 생명주기 관리)
    
    - 앞서 구현한 웹서버는 서버를 시작하는 시점에 Controller 인스턴스를 생성하고, 요청 url과 생성된 Controller 인스턴스를 연결해 놓는다. 또한 클라이언트로부터 요청이 오면 해당하는 Controller를 찾아 Controller에 실질적인 작업을 위임한다.
    
    - **서블릿 = Controller / 서블릿 컨테이너 = RequestHandler**
      
      추가 : HttpServletRequest= HttpRequest, HttpServletResponse = HttpResponse, Servlet 인터페이스 = Controller 인터페이스, HttpServlet = AbstractController

    (서블릿 컨테이너는 서버를 시작할 때 classpath에 있는 클래스 중 `HttpServlet`를 상속하는 클래스를 찾은 후, `@WebServlet` 어노테이션의 값을 읽어 요청 url을 연결하는 Map을 생성한다.)

    - 대표적인 서블릿 컨테이너 구현체로는 Tomcat, Jetty, JBoss가 있다.
      
  - 자바에서 **컨테이너** 는 기본적으로 생명주기를 관리하는 기능을 제공한다. 개발자가 직접 객체를 관리하지 않는다. (ex. 스프링 컨테이너는 스프링 빈에 대한 생명주기를 관리하는 기능을 제공한다.)
